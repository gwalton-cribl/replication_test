exports.jobType="task-per-node";exports.name="clear_pq_input";const fs=require("fs");let inputId;let pqPath;let inputType;const{util:{resolveEnvVars},internal:{PersistentQueue:{outputPath,orphanAssignments}}}=C;exports.initJob=async t=>{const{conf:s}=t.conf.executor;inputId=s.inputId;pqPath=s.pqPath;inputType=s.inputType};exports.jobSeedTask=async()=>({task:{inputId,pqPath,inputType}});exports.initTask=async t=>{};exports.jobOnError=async(t,s,e)=>{};exports.taskExecute=async(t,s)=>{const e=t.logger();e.info("task opts",{opts:s});let p=s.pqPath;if(!p){p=await outputPath()}if(typeof p!=="string"||p.length===0)throw{message:"Misconfigured persistent queue path"};const n=resolveEnvVars(p);const i=await fs.promises.readdir(n);if(i.length>0){await Promise.all(i.map((async t=>{const p=[`${n}/${t}/inputs/${s.inputId}`];if(s.inputType==="syslog"){p.push(`${n}/${t}/inputs/${s.inputId}:tcp`);p.push(`${n}/${t}/inputs/${s.inputId}:udp`)}return Promise.all(p.map((async t=>{e.debug("deleting path with retries",{path:t});return fs.promises.rm(t,{recursive:true,maxRetries:10,force:true})})))})))}const r=await orphanAssignments();if(r.length>0){await Promise.all(r.map((t=>{const e=[`${t}/inputs/${s.inputId}`];if(s.inputType==="syslog"){e.push(`${t}/inputs/${s.inputId}:tcp`);e.push(`${t}/inputs/${s.inputId}:udp`)}return Promise.all(e.map((t=>fs.promises.rm(t,{recursive:true,maxRetries:10,force:true}))))})))}e.debug("orphans",{assignedPaths:r})};