exports.name="Database";exports.version="0.1";exports.disabled=false;exports.destroyable=false;const stream=require("stream");let conf;let queryExpression;let ctx;const isSelect=t=>{const e=t.split(";");if(e.length>2||e.length===2&&e[1].trim()!==""){return false}return t.trim().toLowerCase().startsWith("select")};class StateReportingTransform extends stream.Transform{constructor(t,e,n){super({objectMode:true,...t});this.job=e;this.state=n}_transform(t,e,n){if(!Object.hasOwn(t,conf.stateTracking.trackingColumn)){this.destroy(`Tracking column "${conf.stateTracking.trackingColumn}" was missing from row`);return}const r=t[conf.stateTracking.trackingColumn];if(typeof r!=="number"&&typeof r!=="string"){this.job.logger().error("Invalid row value for tracking column, must be a number or string",{valueType:typeof r,column:conf.stateTracking.trackingColumn});this.destroy(`Tracking column "${conf.stateTracking.trackingColumn}" contained non-number/non-string value`);return}this.state[conf.stateTracking.trackingColumn].value=r;this.job.reportState(this.state);this.push(t);n()}_flush(t){this.job.logger().debug("State after processing results",{state:this.state});t()}}exports.metricDims=()=>{const t=conf.connectionId;const e=getDatabaseConnectionMgr();return{databaseType:e.getDatabaseType(t)}};exports.UT_getAllMetricDims=()=>{const t=getDatabaseConnectionMgr();const e=[];for(const n of t.getDatabaseTypes()){e.push({databaseType:n})}return e};function extractContext(t){if(t){const e=t.lastIndexOf(".");if(e!==-1){return t.substring(0,e)}}return undefined}exports.init=async t=>{conf=t.conf||{};const{Expression:e}=C.expr;const n=t.conf.collectorId;ctx=extractContext(n);queryExpression=new e(conf.query,{disallowAssign:true});if((conf.queryValidationEnabled??true)&&!isSelect(queryExpression.evalOn({}))){throw new Error("Invalid config - Must provide only a single SELECT query")}};function getDatabaseConnectionMgr(){return ctx?C.internal.DatabaseConnectionsMgr.inContext(ctx):C.internal.DatabaseConnectionsMgr.instance()}exports.discover=async t=>{await t.addResult({format:"raw",stateKey:"databaseCollectorState"})};exports.collect=async(t,e)=>{const n=conf.connectionId;let r;try{const t=getDatabaseConnectionMgr();r=t.getConnection(n,e.logger())}catch(t){e.reportError(t)}if(r==null){throw new Error(`Can't find Database Connection '${n}'`)}let o=t.state;const a=r.prepareStatement(queryExpression,o);if(a){const t={};try{const n=a.preparedStatement;const s=a.referencedVariables;for(const e of s){if(e==="earliest"){t["earliest"]=new Date(isNaN(+conf.earliest)?Date.now():conf.earliest*1e3).toISOString()}else if(e==="latest"){t["latest"]=new Date(isNaN(+conf.latest)?Date.now():conf.latest*1e3).toISOString()}else{t[e]=o[e].value}}e.logger().debug("Query",{preparedStatement:n,args:t});let c=await r.executeQuery(n,o,t);if(conf.stateTracking?.enabled){if(!o){o={[conf.stateTracking.trackingColumn]:{value:null}}}e.logger().debug("State before processing results",{state:o});const t=new StateReportingTransform({},e,o);c=stream.pipeline(c,t,(()=>{}))}const i=await C.internal.stringifyReadableObjects(c);return i}catch(t){e.reportError(new Error("Collect error",{err:t})).catch((()=>{}));throw t}}else{e.reportError(new Error("Unable to prepare statement",{queryExpression})).catch((()=>{}))}};